---
title: "Map data from INBO color ring database to crbirding (SOVON)"
author: 
- Damiano Oldoni
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: true
    theme: yeti
    df_print: paged
knit: (function(input_file, encoding) { rmarkdown::render(input_file, encoding = encoding, output_file = paste0("./docs/",sub(".Rmd", ".html", basename(input_file))))})
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

# Goal

This pipeline will:

1. extract data from INBO *kleurring* database (official name: `D0016_00_Meeuwen`)
2. transform data to SOVON format
3. export data in text files

# Setup

Load libraries:

```{r load_libraries}
library(DBI) # To connect to database
library(odbc) # To connect to database
library(stringr) # To perform string operations
library(stringi) # To perform string operations
library(readr) # To read and write txt files
library(dplyr) # To transform data
library(tidyr) # To transform data
library(purrr) # To transform data via loops
library(measurements) # To convert units of measurement 
library(here) # To find files
library(lubridate) # To ease working with dates
```

Set output file paths:

```{r file_paths}
cr_users_file <- here::here("data", "processed", "data_users.tsv")
cr_birds_file <- here::here("data", "processed", "data_birds.tsv")
cr_obs_file <- here::here("data", "processed", "data_observations.tsv")
```

# Extract data from INBO kleurring database

## Connection to INBO database

We establish a connection to the database. Sensible data are saved in the `.Renviron` file:

```{r connect_to_db}
conn <- dbConnect(odbc::odbc(),
                  driver = Sys.getenv("driver"),
                  server = Sys.getenv("server"),
                  database = Sys.getenv("database"),
                  port = Sys.getenv("port"),
                  trusted_connection = Sys.getenv("tc"))
```

## Extract data

### Extract user data

First, we extract data about users from INBO *kleurring* database:

```{r get_user_data}
users <-  dbGetQuery(conn, "SELECT * FROM dbo.tblWaarnemer") %>%
    as_tibble()
```

### Extract color ring data

```{r get_birds_data}
birds <- dbGetQuery(conn, "SELECT * FROM dbo.tblKleurring") %>%
  as_tibble()
```

### Extract observation data

INBO's observation data contain a text type field: `Opmerking`. Text type is deprecated and an error will be returned if we perform the standard SQL query `"SELECT * FROM dbo.tblWaarneming"`. So, we need an ad-hoc query:

```{r get_obs_data}
obs <- dbGetQuery(conn,
  "SELECT Nummer,
          Datum,
          EuringCode,
          LeeftijdCode,
          KleurringNummer,
          KleurringPlaats,
          MetaalringNummer,
          MetaalringPlaats,
          PlaatsGemeente,
          PlaatsToponym,
          PlaatsToponymDetail,
          Convert(nvarchar(4000),Opmerking) as Opmerking,
          WaarnemerNummer,
          PlaatsLengtegraadGraden,
          PlaatsLengtegraadMinuten,
          PlaatsLengtegraadSeconden,
          PlaatsBreedtegraadGraden,
          PlaatsBreedtegraadMinuten,
          PlaatsBreedtegraadSeconden,
          PlaatsLengtegraadRichtingCode,
          PlaatsBreedtegraadRichtingCode,
          PlaatsLandCode,
          MetaalringLandCode,
          BevestigingDatum,
          PlaatsProvincie,
          AanmaakDatum,
          WijzigDatum
  FROM dbo.tblWaarneming") %>% as_tibble()
```

Table `tblWaarnemingAktie` is also important because contains informations about the actions the observations refer to:

```{r get_waarnemingAktie}
obs_actions <- dbGetQuery(conn, "SELECT * FROM dbo.tblWaarnemingAktie")
```

The action codes are described in table `dbo.cdeAktie`:

```{r get_}
actions_meaning <- dbGetQuery(conn, "SELECT * FROM dbo.cdeAktie")
actions_meaning
```

### Import control data

The INBO seebird team provided a spreadsheet to map color rings (see section [bird shorthand](#bird-shorthand)). From this spreadhseet we distilled some text files with specific mapping information:

```{r import_csv_from_control_spreadsheet}
map_gps_path <- here::here("data", "input", "map_gps_id_to_color_ring.tsv")
map_gps <- read_tsv(map_gps_path)
map_gps %>% head()
```

## Pre-processing

### Add prefix `raw_` to columns

Add prefix `raw_` to all column names to avoid any possible name clash with SOVON terms (for more info see [spreadsheet](https://docs.google.com/spreadsheets/d/16928bSQzZ0jz0FCf5gXZ4Rg4gf9qYQPO5izLZ5IYSTQ/edit?usp=drive_web&ouid=109004011205942623101) and [document](https://docs.google.com/document/d/1VtwGD4wrwJLnGnvJprtFB3MbbXdirMELYvuCGEhLr3w/edit)) as provided by SOVON (access restricted).

```{r add_raw}
colnames(users) <- paste0("raw_", colnames(users))
colnames(birds) <- paste0("raw_", colnames(birds))
colnames(obs) <- paste0("raw_", colnames(obs))
colnames(obs_actions) <- paste0("raw_", colnames(obs_actions))
```

### Preview data

For privcay reasons users data cannot be shown. Users data refer to the following fields:

```{r prview_users}
colnames(users)
```

Preview birds data:

```{r preview_birds}
birds %>% head()
```

Preview observations data:

```{r preview_obs}
obs %>% head()
```

Preview observation actions data:

```{r prview_obs_actions}
obs_actions %>% head()
```

### Check duplicates `raw_WaarnemingNummer`-`raw_AktieCode`

The action acronym is contained in column `raw_AktieCode`. Observations and their action are linked via columns `raw_WaarnemingNummer` (in `obs_actions`) and `raw_Nummer` (in `obs`).

No duplicates `raw_WaarnemingNummer`-`raw_AktieCode` should exist:

```{r show_duplicates_obs_actions}
obs_actions %>% filter(raw_WaarnemingNummer %in% 
                         (obs_actions %>% 
                         group_by(raw_WaarnemingNummer, 
                                  raw_AktieCode) %>% 
                         count() %>%
                         filter(n > 1) %>%
                         pull(raw_WaarnemingNummer)))
```

Otherwise they should be removed:

```{r to_be_removed_after}
obs_actions <- obs_actions %>% 
  distinct(raw_WaarnemingNummer, 
           raw_AktieCode, .keep_all = TRUE)
```

### Check presence action code

All observations should also have an action code:

```{r observations_without_action}
obs %>% 
  filter(!raw_Nummer %in% 
           (obs_actions %>% pull(raw_WaarnemingNummer)))
```

Observation without it will be removed:

```{r remove_observations_without_action}
obs <- obs %>% 
  filter(raw_Nummer %in% 
           (obs_actions %>% pull(raw_WaarnemingNummer)))
```

### Check spaces in `birds`

No spaces should be present in any column of `birds`:

```{r check_spaces}
map_dfr(birds, ~ mutate(birds, space_detect = str_detect(., pattern = " "))) %>%
  filter(space_detect == TRUE)
```

Remove all spaces:

```{r remove_spaces}
birds <- birds %>% 
  mutate_all(funs(str_replace(., " ", "")))
```

### Merge observations and actions

In order to ease the mapping of birds and observations, we add action codes to observations in order to have a unique **tidy** data frame:

```{r merge_obs_with_acts}
obs_and_acts <- obs %>% 
  left_join(obs_actions %>% 
              select(-c(raw_Nummer, 
                        raw_AanmaakDatum, 
                        raw_WijzigDatum)),
            by = c("raw_Nummer" = "raw_WaarnemingNummer"))
```

### Check spaces in `obs_and_acts`

No spaces should be present in character columns of `obs_and_acts` except for columns related to place description (`raw_Plaats*`), datums (`*Datum`) and notes (`raw_Opmerking`):

```{r show_spaces_obs_and_acts}
map_dfr(obs_and_acts %>%
          select_if(is.character) %>%
          select(-c(starts_with("raw_Plaats"), 
                    raw_Opmerking, 
                    ends_with("Datum"))), ~ 
          mutate(obs_and_acts, space_detect = str_detect(., pattern = " "))) %>%
  filter(space_detect == TRUE) %>%
  arrange(raw_Nummer)
```

Remove spaces:

```{r remove_spaces_from_obs_and_acts}
obs_and_acts <- obs_and_acts %>% 
  mutate_at(vars(-c(starts_with("raw_Plaats"),
                 ends_with("Datum"),
                 one_of("raw_Opmerking", "raw_Nummer", "raw_WaarnemerNummer"))), 
            funs(str_replace(., " ", "")))
```

### Remove data labelled as `FOUT`

There are observations judged as error. They are marked by`raw_KleurringNummmer` equal to `FOUT`:

```{r show_FOUT_obs}
obs_and_acts %>% 
  filter(raw_KleurringNummer == "FOUT") %>%
  head(n = 10)
```

The value `FOUT` is also present in `birds`:

```{r show_FOUT_birds}
birds %>% 
  filter(raw_Nummer == "FOUT")
```

These data are related to observations judged not correct (`FOUT`: _error_) by the INBO experts and administrator of the database.

Thus, at the moment, we remove these data (discussion about this issue [here](https://github.com/inbo/sovon/issues/9)):

```{r remove_FOUT}
obs_and_acts <- obs_and_acts %>% filter(raw_KleurringNummer != "FOUT")
birds <- birds %>% filter(raw_Nummer != "FOUT")
```

### Check color rings: uppercase

Bird color rings codes are uppercase. Exceptions:

```{r show_rings_lowercase}
birds %>%
  filter(raw_Nummer != toupper(raw_Nummer) | 
           raw_NummerNieuw != toupper(raw_NummerNieuw))
```

are converted to uppercase:

```{r convert_rings_to_uppercase}
birds <- birds %>%
  mutate(raw_Nummer = toupper(raw_Nummer),
         raw_NummerNieuw = toupper(raw_NummerNieuw),
         raw_NummerDesc = toupper(raw_NummerDesc))
```

The same holds true for `raw_KleurringNummer` in `obs_and_acts`. Exceptions:

```{r lowercase_raw_kleurringNummer}
obs_and_acts %>% 
  filter(raw_KleurringNummer != toupper(raw_KleurringNummer)) %>% 
  distinct(raw_KleurringNummer)
```

are transformed to uppercase:

```{r raw_KleurringNummer_to_upper}
obs_and_acts <- obs_and_acts %>% 
  mutate(raw_KleurringNummer = toupper(raw_KleurringNummer))
```

### Check keys `raw_KleurringNummer` (obs) - `raw_Nummer` (birds)

All values in `raw_KleurringNummer` should be present in `birds$raw_Nummer`. Exceptions:

```{r raw_KleurringNummer_not_in_birds_raw_Nummer}
obs_and_acts %>%
  filter(!raw_KleurringNummer %in% birds$raw_Nummer) %>% 
  distinct(raw_KleurringNummer)
```

We remove them:

```{r remove_obs_and_acts_linked_to_invalid_bird_ring}
raw_KleurringNummer_remove <- obs_and_acts %>%
  filter(!raw_KleurringNummer %in% birds$raw_Nummer) %>% 
  distinct(raw_KleurringNummer) %>%
  pull()
obs_and_acts <- obs_and_acts %>% 
  filter(!raw_KleurringNummer %in% raw_KleurringNummer_remove)
birds <- birds %>%
  filter(!raw_Nummer %in% raw_KleurringNummer_remove)
```

Finally, we search for birds (`raw_Nummer` in  `birds`) which are not present in any observation (`raw_KleurringNummer` in `obs_and_acts`):

```{r birds_not_in_obs}
birds %>% filter(!raw_Nummer %in% obs_and_acts$raw_KleurringNummer)
```

We remove them:

```{r remove_birds_not_in_obs}
birds <- birds %>% 
  filter(raw_Nummer %in% obs_and_acts$raw_KleurringNummer)
```

### Check duplicates in date of applying (color) ring

We control the presence of duplicates in date of applying color or metal rings (action code `rngkl` or `rngme`):

```{r duplicates_apply_color_rings}
duplicates_ringing <- obs_and_acts %>%
  filter(raw_AktieCode %in% c("rngkl", "rngme")) %>%
  filter(raw_KleurringNummer %in% (
    obs_and_acts %>% 
      filter(raw_AktieCode %in% c("rngkl", "rngme")) %>%
      group_by(raw_KleurringNummer, raw_Datum, raw_AktieCode) %>%
      count() %>%
      filter(n > 1) %>%
      pull(raw_KleurringNummer))) %>%
  arrange(raw_KleurringNummer)
duplicates_ringing
```

If no inconsistencies are detected in other columns (e.g. bird age or place while ringing), duplicates can be removed:

```{r remove_duplicates_ringing}
obs_and_acts <- bind_rows(obs_and_acts %>% 
            filter(raw_AktieCode %in% c("rngkl", "rngme")) %>%
            distinct(raw_Datum, raw_KleurringNummer, raw_AktieCode, 
                     .keep_all = TRUE),
          obs_and_acts %>%
            filter(!raw_AktieCode %in% c("rngkl", "rngme")))
```

### Handle information about metal ring number

There are columns containing metal ring related information in `birds`:

```{r cols_metal_ring_birds}
names(birds)[which(grepl("raw_Metaalring", names(birds)))]
```

and `obs_and_acts`:

```{r cols_metal_ring_obs_and_acts}
names(obs_and_acts)[which(grepl("raw_Metaalring", names(obs_and_acts)))]
```

This is not only redundant: inconsistencies are detected. Some examples:

```{r inconsisntecy_metal_ring_info_examples}
birds %>%
  filter(raw_Nummer %in% c("AAAA", "AAAR", "AAAT", "AAAW")) %>%
  rename("metal_ring_from_birds"  = "raw_MetaalringNummer") %>%
  left_join(obs_and_acts %>%
              rename("metal_ring_from_obs"  = "raw_MetaalringNummer"),
            by = c("raw_Nummer" =  "raw_KleurringNummer")) %>%
  distinct(raw_Nummer, metal_ring_from_birds, metal_ring_from_obs)
```

Based on expert's knowledge only the metal ring information in `birds` is correct. We remove the columns related to metal ring information from `obs_and_acts` as this information is redundant and not needed for the mapping:

```{r remove_metal_ring_infos_from_obs}
obs_and_acts <-
  obs_and_acts %>%
  select(-starts_with("raw_Metaalring"))
```

### Solve GPS tracker IDs

Some birds have a suspect `raw_Nummer` which is formed by letters `GPS` or `GP` followed by some numbers. These are a kind of GPS IDs which should not be in columns related to color rings:

```{r show_gps_ids}
birds %>%
  filter(str_detect(raw_Nummer, pattern = "(^(GP)\\d+)|(^(GPS)\\d+)")) %>%
  select(raw_Nummer)
```

The right mapping of them is saved in `map_gps`:

```{r preview_map_gps}
map_gps %>% head()
```

We import the color rings in new column `first_Nummer`. For all other rings will be `first_nummer = raw_Nummer` as they are the very first rings. We will also add note `'uvabits_gps_tag'`

```{r map_to_first_Nummer}
map_gps_add_notes <- map_gps %>%
  mutate(bird_notes = "uvabits_gps_tag.")
birds <- birds %>%
  # create column first_Nummer with right color rings for the GPS or GP** rings
  left_join(map_gps_add_notes, by = c("raw_Nummer" = "gps_id")) %>%
  # set first_Numer equal to raw_Nummer in all other cases
  mutate(first_Nummer = ifelse(is.na(color_ring),
                               raw_Nummer,
                               color_ring)) %>%
  select(raw_Nummer, first_Nummer, everything())
```

Check whether not corrected rings (`GP***` or `GPS***`) are still present:

```{r check_presence_GP_GPS_in_birds}
birds %>%
  filter(str_detect(first_Nummer, pattern = "(^(GP)\\d+)|(^(GPS)\\d+)")) %>%
  select(first_Nummer)
```

Mapping example: the bird with `raw_Nummer` equal to GP130 is mapped as follows:

```{r example_gps_mapping_and_name}
birds %>%
  filter(raw_Nummer == "GP130") %>%
  select(raw_Nummer, first_Nummer, bird_notes)
```

Column `first_Nummer` should contain unique elements. Check for exceptions:

```{r check_uniqueness_first_Nummer}
birds %>%
  group_by(first_Nummer) %>%
  count() %>%
  filter(n > 1) %>%
  left_join(birds) %>%
  select(-n)
```

Exceptions are due to double entry, one with the original color ring, a second one with GPS tracker ID. Such exceptions should be handled separately while mapping `bird_shorthand`.

# Map data

We tranform the information extracted from INBO color ring database to SOVON format.

## Map user data

We start mapping user data.

### E-mail

```{r e-mail}
users <- users %>%
  mutate(user_email = raw_Email)
```

### First name

```{r first_name}
users <- users %>%
  mutate(user_first_name = raw_Voornaam)
```

### Last name

```{r last_name}
users <- users %>%
  mutate(user_last_name = raw_Familienaam)
```

### Address

```{r address}
users <- users %>%
  mutate(user_address = raw_Adres)
```

### Place

```{r place}
users <- users %>%
  mutate(user_place = raw_Gemeente)
```

### Postal code

```{r postal_code}
users <- users %>%
  mutate(user_postal_code = raw_Postcode)
```

### Country

```{r country}
users <- users %>%
  mutate(user_country = raw_LandCode)
```

### User ID

User identifiers are provided by SOVON. `NA` is given.

```{r userID}
users <- users %>%
  mutate(user_id  = NA)
```

### User reference

Field provided by SOVON: `NA` is given

```{r user_ref}
users <- users %>%
  mutate(user_reference  = NA)
```

### User language

This field is not present in `users`. However, all accounts have been made by INBO in Dutch:

```{r user_language}
users <- users %>%
  mutate(user_language  = "Dutch")
```

### User role

The distinction between ringer and observer is not present in `users`, but can be retrieved by combining it with `obs_and_acts`.

We filter by ring actions (`rngkl` or `rngme`) and we retrieve the ringers by `raw_WaarnemerNummer`:

```{r find_ringers}
ringers_number <- obs_and_acts %>% 
  filter(raw_AktieCode %in% c("rngkl","rngme")) %>%
  distinct(raw_WaarnemerNummer) %>% pull()
print(paste("Number of ringers:", 
            length(ringers_number)))
```

And we assign a `R` (ringer) to them, `O` (observer) otherwise:

```{r assign_ringer}
users <- users %>%
  mutate(user_role = ifelse(raw_Nummer %in% ringers_number,
                      "R", "O"))
```

## Map color ring data

### Bird reference

The relation color ring (SOVON field `bird_shorthand`) - bird is a multi-to-one relation. By assigning a bird reference as unique integer to a bird we can link any color ring to the bird it belongs to.

```{r bird_reference}
birds <- birds %>%
  mutate(bird_reference = seq_len(nrow(birds))) %>%
  select(bird_reference, first_Nummer, raw_NummerNieuw, 
         raw_NummerDesc, everything())
head(birds)
```

We have to solve the lack of unicity discussed in preprocessing, which ends up in multiple `bird_reference` for the same bird. See here the few issues encountered:

```{r issues_shorthand}
birds %>%
  group_by(first_Nummer) %>%
  count() %>%
  filter(n > 1) %>%
  left_join(birds %>%
              select(bird_reference, 
                     first_Nummer, 
                     raw_NummerNieuw, 
                     raw_NummerDesc, 
                     raw_Nummer),
            by = "first_Nummer") %>%
  select(-n)
```

We assign the lower `bird_reference`:

```{r solve_unicity_issues}
birds <-
  birds %>%
  group_by(first_Nummer) %>%
  mutate(bird_reference = min(bird_reference)) %>%
  ungroup()
```

Check:

```{r check_solution_unicity_shorthand}
birds %>%
  group_by(first_Nummer) %>%
  count() %>%
  filter(n > 1) %>%
  left_join(birds %>%
              select(bird_reference, 
                     first_Nummer, 
                     raw_NummerNieuw, 
                     raw_NummerDesc, 
                     raw_Nummer),
            by = "first_Nummer") %>%
  select(-n)
```

We add column `bird_reference` to `obs_and_acts` as it will be needed to map the dates of ringing. The link is made by the columns `raw_Nummer` (birds data) and  `raw_KleurringNummer` (observation data):

```{r apply_bird_ref_to_obs_acts}
obs_and_acts <- 
  obs_and_acts %>%
  left_join(birds %>% select(raw_Nummer, bird_reference),
            by = c("raw_KleurringNummer" = "raw_Nummer")) %>%
  select(bird_reference, everything())
```

Check whether there are observation without link to any bird:

```{r check_NA_bird_ref}
filter(obs_and_acts, is.na(bird_reference))
```

We will also add column `first_Nummer` from birds to observations as well:

```{r add_first_Nummer_to_obs_and_acts}
obs_and_acts <- 
  obs_and_acts %>%
  left_join(
    birds %>%
      select(bird_reference, first_Nummer, raw_Nummer),
    by = c("bird_reference", 
           "raw_KleurringNummer" = "raw_Nummer")
)
```

The reconstruction of the series of color rings for each bird is made by using columns `first_Nummer`, `raw_NummerNieuw` and the information from spreadsheets of experts. We will collect the needed information in new dataframe, called `crbirding_birds` which will grow up to become the end product of color ring table.

First step is to *gather* `first_Nummer`  and `raw_NummerNieuw` in new column `bird_shorthand`. We do it and we create a new data.frame called `crbirding_birds` which will be the end product related to rings:

```{r backbone_mapping_shorthand}
crbirding_birds <- 
  birds %>%
  select(bird_reference, first_Nummer, 
         raw_NummerNieuw, raw_NummerDesc, bird_notes) %>%
  gather(key = col_nummer,
         value = bird_shorthand,
         first_Nummer, raw_NummerNieuw) %>%
  select(-col_nummer) %>%
  select(bird_reference, bird_shorthand, raw_NummerDesc, bird_notes)
```

We can also assign the color ring version with point (`bird_shorthand_pt`) by matching columns `bird_shorthand` and `raw_NummerDesc` where possible. Note that `bird_shorthand_pt` may contain points, but for old rings it is equal to `bird_shorthand`:

```{r map_shorthand_with_point}
crbirding_birds <-
  crbirding_birds %>%
  mutate(bird_shorthand_pt = ifelse(
    str_remove_all(string = raw_NummerDesc, pattern = "\\.") == bird_shorthand,
    raw_NummerDesc,
    bird_shorthand)
    ) %>%
  distinct() %>%
  select(bird_reference, bird_shorthand, bird_shorthand_pt, bird_notes) %>%
  # to map correctly MKAU (bird_reference: 3716)
  group_by(bird_reference, bird_shorthand) %>%
  filter(bird_shorthand_pt == bird_shorthand_pt[which.max(nchar(bird_shorthand_pt))])
```

Example of mapping: the bird with `bird_reference` 14 is associated to the following two rings:

```{r example_mapping_shorthand_birds}
birds %>%
  filter(bird_reference == 14) %>%
  select(bird_reference, first_Nummer, raw_NummerNieuw, raw_NummerDesc)
```

and will be mapped as follows:

```{r example_mapping_shorthand}
crbirding_birds %>%
  filter(bird_reference == 14) %>%
  select(bird_reference, bird_shorthand, bird_shorthand_pt)
```

Another example:

```{r example_bird_ref_3716}
crbirding_birds %>%
  filter(bird_reference == 3716) %>%
  select(bird_reference, bird_shorthand, bird_shorthand_pt)
```

### Bird ringing date

The date of ringing (to be mapped as `bird_date_begin`) can be found in data frame `obs_and_acts` in the column `raw_Datum` relatively to code action `rngkl` (code action of applying colour ring).

```{r example_rngkl_actions}
obs_and_acts %>% 
  filter(raw_AktieCode == "rngkl") %>%
  select(bird_reference, first_Nummer, 
         raw_Datum, raw_AktieCode) %>%
  head(n = 10)
```

We can add automatically the date of the very first ring for each bird (`bird_reference`), based on date of action code `rngkl`. In fact, there should be just one observation with action `rngkl` for each bird (`bird_reference`). Exceptions:

```{r exception_rule_one_bird_one_rngkl}
exceptions_one_bird_one_rngkl <- obs_and_acts %>%
  filter(raw_AktieCode == "rngkl") %>%
  select(bird_reference, raw_Datum) %>%
  group_by(bird_reference) %>%
  count() %>%
  filter(n > 1) %>%
  left_join(obs_and_acts %>%
              select(bird_reference, raw_Datum, raw_AktieCode),
            by = "bird_reference") %>%
  filter(raw_AktieCode == "rngkl") %>%
  left_join(crbirding_birds %>%
              select(bird_reference, bird_shorthand),
            by = "bird_reference") %>%
  distinct() %>%
  select(-n)
exceptions_one_bird_one_rngkl
```

We will manage the very few exceptions later.

Assign the date of first ringing:

```{r get_first_ring_date}
crbirding_birds <- 
  obs_and_acts %>%
  filter(raw_AktieCode == "rngkl") %>%
  select(bird_reference, first_Nummer, raw_Datum) %>%
  group_by(bird_reference, first_Nummer) %>%
  summarize(bird_date_begin = min(raw_Datum)) %>%
  right_join(crbirding_birds,
             by = c("bird_reference", 
                    "first_Nummer" = "bird_shorthand")) %>%
  rename(bird_shorthand = first_Nummer) %>%
  select(bird_reference, bird_shorthand, bird_shorthand_pt, 
         bird_date_begin, bird_notes)
```

Some examples (birds with `bird_reference` 1, 14 and 4543):

```{r examples_date_ringing}
crbirding_birds %>%
  filter(bird_reference %in% c(1, 14, 4543)) %>%
  arrange(bird_reference, bird_date_begin)
```

Check date of birds in exceptions:

```{r check_date_of_exceptions_double_rngkl}
crbirding_birds %>%
  filter(bird_shorthand %in% c("MKAU", "CZOZ"))
```

And in case solve:

```{r solve_date_of_exceptions_double_rngkl, evaluate = FALSE}
crbirding_birds <- 
  crbirding_birds %>% 
  mutate(bird_date_begin = case_when(
    bird_shorthand == "MKAU" ~ bird_date_begin,
    bird_shorthand ==  "CZOZ" ~ as.POSIXct(NA_character_),
    TRUE ~ bird_date_begin
    )
  )
```

Summary of rings with date (`bird_date_begin`):

```{r summary_n_rings_with_date}
crbirding_birds %>%
  mutate(date_is_present = !is.na(bird_date_begin)) %>%
  group_by(date_is_present) %>%
  count()
```

The rings without date are the last rings of birds ringed more than once. 

```{r summary_bird_with_more_rings}
birds_multiple_rings <- 
  crbirding_birds %>%
  group_by(bird_reference) %>%
  count() %>%
  filter(n > 1)
birds_multiple_rings
```

Not only, the structure of our database limits to 2 the maximum number of rings linked to the same bird, as two are the columns containing such information (`raw_Nummer` and `raw_NummerNieuw`):

```{r check_max_rings_is_2}
birds_two_rings <- 
  crbirding_birds %>%
  group_by(bird_reference) %>%
  count() %>%
  filter(n == 2)
all(birds_two_rings$bird_reference == birds_multiple_rings$bird_reference)
```

Experts explained us that the very first and the very last ring are mapped in `birds`. By consulting the spreadsheet of the experts we will later fill the gap by adding _intermediate rings_.

We can try to retrieve the date of applying last ring based on observations/actions with code `vang` (caught at the nest) or `vangl` (caught otherwise). Birds ringed twice and linked to one `vang`/`vangl` action:

```{r birds_two_rings_one_vang}
bird_one_vang <- obs_and_acts %>%
  filter(bird_reference %in% birds_multiple_rings$bird_reference,
         raw_AktieCode %in% c("vang", "vangl")) %>%
  select(bird_reference, raw_Datum) %>%
  group_by(bird_reference) %>%
  count() %>%
  filter(n == 1) %>%
  left_join(obs_and_acts %>%
              select(bird_reference, raw_Datum, raw_AktieCode),
            by = "bird_reference") %>%
  filter(raw_AktieCode %in% c("vang", "vangl")) %>%
  rename("bird_date_begin" = "raw_Datum") %>%
  arrange(bird_reference)
bird_one_vang
```

As you cannot change a ring without catching him, we can use these unique dates as date of ringing, `bird_date_begin`:

```{r set_date_ringing_bird_catched_once}
bird_one_vang_with_date <- 
  crbirding_birds %>%
  filter(bird_reference %in% bird_one_vang$bird_reference,
         bird_reference %in% birds_two_rings$bird_reference) %>%
  group_by(bird_reference) %>%
  filter(is.na(bird_date_begin)) %>%
  select(-bird_date_begin) %>%
  left_join(bird_one_vang, 
            by = c("bird_reference")
  ) %>%
  select(-c(n, raw_AktieCode))
crbirding_birds <- 
  crbirding_birds %>%
  anti_join(bird_one_vang_with_date,
            by = c("bird_reference", "bird_shorthand")) %>%
  bind_rows(bird_one_vang_with_date) %>%
  arrange(bird_reference)
```

Examples of date mapping (birds with `bird_reference` 11 and 14):

```{r examples_assign_date_second_ring_by_vang_date}
crbirding_birds %>%
  filter(bird_reference %in% c(11, 14))
```

Some birds have been catched twice:

```{r birds_two_rings_two_vang}
bird_two_vang <- obs_and_acts %>%
  filter(bird_reference %in% birds_two_rings$bird_reference,
         raw_AktieCode %in% c("vang", "vangl")) %>%
  select(bird_reference, raw_Datum) %>%
  group_by(bird_reference) %>%
  count() %>%
  filter(n == 2) %>%
  left_join(obs_and_acts %>%
              select(bird_reference, raw_Datum, raw_AktieCode),
            by = "bird_reference") %>%
  filter(raw_AktieCode  %in% c("vang", "vangl")) %>%
  rename("bird_date_begin" = "raw_Datum") %>%
  arrange(bird_reference)
bird_two_vang
```

In the expert spreadsheet, we can see that the ring is **typically** applied during the last `vang`/`vangl` action. We will assign the most recent date by default as first step, correcting the exceptions later:

```{r get_second_ring_via_vang}
bird_two_vang_get_date <- 
  crbirding_birds %>%
  filter(bird_reference %in% bird_two_vang$bird_reference,
         bird_reference %in% birds_two_rings$bird_reference) %>%
  group_by(bird_reference) %>%
  filter(is.na(bird_date_begin)) %>%
  select(-bird_date_begin) %>%
  left_join(bird_two_vang %>%
              group_by(bird_reference) %>%
              filter(bird_date_begin == max(bird_date_begin)), 
            by = c("bird_reference")
  ) %>%
  select(-c(n, raw_AktieCode))
bird_two_vang_get_date
```

By consulting the spreadsheet we can find that the following rings have been applied during the earliest `vang`/`vangl` action, so they are exceptions:

```{r correct_zexceptions_bird_date_begin_earliest_date}
bird_shorthand_exceptions <- c("NGAP", "NGAX", "GVAR", 
                               "KPAZ", "KAAK", "KAAN")
bird_exceptions <- 
  crbirding_birds %>%
  filter(bird_shorthand %in% bird_shorthand_exceptions)
```

We set `bird_date_begin` equal to the date of the earliest `vang`/`vangl` action:

```{r}
bird_two_vang_get_date <- 
  bird_two_vang %>%
  filter(bird_reference %in% bird_exceptions$bird_reference) %>%
  group_by(bird_reference) %>%
  filter(bird_date_begin == min(bird_date_begin)) %>%
  left_join(bird_exceptions %>%
              select(-bird_date_begin), by = "bird_reference") %>%
  select(-c(n, raw_AktieCode)) %>%
  select(names(bird_two_vang_get_date)) %>%
  bind_rows(bird_two_vang_get_date %>%
              filter(!bird_shorthand %in% bird_exceptions$bird_shorthand))
```

Add this information to `crbirding_birds`:

```{r}
crbirding_birds <- 
  crbirding_birds %>%
  anti_join(bird_two_vang_get_date,
            by = c("bird_reference", 
                   "bird_shorthand", 
                   "bird_shorthand_pt")) %>%
  bind_rows(bird_two_vang_get_date) %>%
  arrange(bird_reference)
crbirding_birds
```

Rings still without date:

```{r summary_date_begin_after}
crbirding_birds %>%
  mutate(date_is_present = !is.na(bird_date_begin)) %>%
  filter(!date_is_present)
```

Based on spreadsheet and observation data, we found that the dates of applying the rings FAAG and YCAF are linked to actions `ziek`, i.e. the ring has been applied while taking care of the birds. 

The date of applying FAAG:

```{r get_info_FAAG}
info_faag <- 
  crbirding_birds %>%
  filter(bird_shorthand == "FAAG") %>%
  mutate(bird_date_begin = 
           obs_and_acts %>%
           filter(bird_reference == 176, 
                  first_Nummer == "ALAU",
                  raw_AktieCode == "ziek") %>%
           # get the second "ziek" action (2006-07-07)
           filter(raw_Datum == max(raw_Datum)) %>%
           pull(raw_Datum))
info_faag
```

The date of applying YCAF:

```{r get_info_YCAF}
info_ycaf <- 
  crbirding_birds %>%
  filter(bird_shorthand == "YCAF") %>%
  mutate(bird_date_begin = 
           obs_and_acts %>%
           filter(bird_reference == 3293, 
                  first_Nummer == "PLAB",
                  raw_AktieCode == "ziek") %>%
           # there is juwt one "ziek" action
           pull(raw_Datum))
info_ycaf
```

The date of applying FHOV:

```{r get_info_FHOV}
info_fhov <- 
  crbirding_birds %>%
  filter(bird_shorthand == "FHOV") %>%
  mutate(bird_date_begin = 
           obs_and_acts %>%
           filter(bird_reference == 6360, 
                  first_Nummer == "SUAV",
                  raw_AktieCode == "ziek") %>%
           # there is juwt one "ziek" action
           pull(raw_Datum))
info_fhov
```

Add this dates to `crbirding_birds`:

```{r add_to_crbirding_birds}
crbirding_birds <- 
  bind_rows(crbirding_birds %>% 
              filter(!bird_shorthand %in% c("FAAG", "YCAF", "FHOV")),
            info_faag,
            info_ycaf,
            info_fhov) %>%
  arrange(bird_reference, bird_date_begin)
```

Based on spreadsheet of experts, we have to add new rings, as some birds have been ringed more than twice, so the information contained in `first_Nummer` and `raw_NummerNieuw` is not complete, as they map the very first and the very last ring. The intermediate rings are the following:

```{r intermediate_rings_df}
intermediate_rings <- tibble(
    first_Nummer = c(
      "E633",
      "DJAB",
      "BWAD",
      "KLAT",
      "PR3",
      "TY2",
      "RTO",
      "E099",
      "MKAU",
      "ASAH",
      "ADAF"
      ),
    intermediate_ring = c(
      "BUAG",
      "TRAP",
      "GTAS",
      "UPAB",
      "DHAZ",
      "GMAJ",
      "DGAH",
      "GHAT",
      "ZVAU",
      "HWAX",
      "DJAU"
      ),
    bird_date_begin = as.POSIXct(c(
      "2000-05-08", # BUAG
      "2012-05-25", # TRAP
      "2007-06-01", # GTAS
      "2012-05-29", # UPAB
      "2006-05-26", # DHAZ 
      "2007-06-06", # GMAJ
      "2006-05-17", # DGAH
      "2007-06-18", # GHAT
      "2014-05-23", # ZVAU
      "2009-05-18", # HWAX
      "2006-05-26" # DJAU
      ), tz = "UTC")
)
intermediate_rings
```

Retrieve `bird_reference`:

```{r retrieve_bird_ref_intermediate_rings}
intermediate_rings <- 
  intermediate_rings %>%
  left_join(crbirding_birds %>%
              select(bird_reference, bird_shorthand),
            by = c("first_Nummer" = "bird_shorthand")) %>%
  select(bird_reference, first_Nummer, intermediate_ring, bird_date_begin)
intermediate_rings
```

Check whether all dates are linked to a valid observation and check whether they are linked to `vang/vangl` actions:

```{r get_actins_intermediate_rings}
intermediate_rings %>%
  left_join(obs_and_acts %>%
              select(bird_reference, 
                     raw_Datum, 
                     raw_AktieCode, 
                     first_Nummer), 
            by = c("bird_reference", 
                   "bird_date_begin" = "raw_Datum",
                   "first_Nummer")) %>%
  filter(raw_AktieCode %in% c("vang", "vangl"))
```

We can then add the intermediate rings to  `crbirding_birds`:

```{r add_intermediate_ring}
crbirding_birds <- 
  crbirding_birds %>%
  bind_rows(intermediate_rings %>%
              select(-first_Nummer) %>%
              rename(bird_shorthand = intermediate_ring) %>%
              mutate(bird_shorthand_pt = bird_shorthand)) %>%
  arrange(bird_reference, bird_date_begin)
```

Example of a triplet ring sequence:

```{r}
crbirding_birds %>% filter(bird_reference == 7592)
```

All rings should be now have a `bird_date_begin`:

```{r summary_n_rings_with_date_final}
crbirding_birds %>%
  mutate(date_is_present = !is.na(bird_date_begin)) %>%
  group_by(date_is_present) %>%
  count()
```

### Bird ringing end date

For birds ringed more than once, we can assign an end date for the changed rings. This information will be stored in field `bird_date_end`. The end date is equal to the date of applying the new ring

```{r assign_bird_date_end}
assign_end_date <- function(data) {
  if (nrow(data) > 1) {
    return(c(as_date(data$bird_date_begin[2:nrow(data)], tz = "UTC"), 
             as_date(NA, tz = "UTC")))
  } else {
    return(as_date(NA, tz = "UTC"))
  }
}

crbirding_birds <- 
  crbirding_birds %>%
  arrange(bird_reference, bird_date_begin) %>%
  group_by(bird_reference) %>%
  nest() %>%
  mutate(bird_date_end = map(data, assign_end_date)) %>%
  unnest() %>%
  select(bird_reference, bird_shorthand, bird_shorthand_pt, 
         bird_date_begin, bird_date_end, bird_notes)
```

Some examples:

```{r examples_bird_date_end}
crbirding_birds %>%
  filter(!is.na(bird_date_end)) %>%
  head(n = 10)
```

### Ring number

The _ring number_, or _metal ring number_, can be found in field `raw_MetaalringNummer`. Ring number should consist of up to ten **alphanumeric** characters. At page 7 of the [EURING Exchange Code 2000+ document](https://euring.org/files/documents/E2000PLUSExchangeCodev1161.pdf) we read the following instructions:

> Where the ring number consist of fewer than ten numbers/letters, the number is padded with dots. These dots are always inserted to the left of the rightmost
row of numbers.

Ring number anomalies:

```{r anomalies_ring_number}
birds %>%
  filter(!str_detect(raw_MetaalringNummer, pattern = regex("\\d+"))) %>%
  group_by(raw_MetaalringNummer) %>%
  count()
```

Value `none` means _not metal-ringed bird_, while `onbekend` means that information is no more available. SOVON chooses to leave column `bird_ring_number` empty for both cases and adding a note in `bird_notes` column. Value `?` is equivalent to `onbekend` while `H????????` and `Lxxxxxx` are mapped as `H--------` and `L------` respectively.

```{r solve_anomalies_bird_ring_number}
birds <- 
  birds %>%
  mutate(bird_ring_number = recode(raw_MetaalringNummer,
                              "?" = NA_character_,
                              "onbekend" = NA_character_,
                              "none" = NA_character_,
                              "H????????" = "H--------",
                              "Lxxxxxx" = "L------")) %>%
  mutate(bird_notes = case_when(
    raw_MetaalringNummer %in% c("?", "onbekend") ~ "bird_ring_number not anymore available.",
    is.na(raw_MetaalringNummer) ~ "bird_ring_number not available.",
    raw_MetaalringNummer == "none" ~ "bird_ring_number not present."))
```

We separate the birds with special mapping values by all the others:

```{r hold_special_values}
special_values <- c("H--------", "L------")
birds_special_values <- 
  birds %>%
  filter(bird_ring_number %in% special_values)
birds_others <- 
  birds %>%
  filter(!bird_ring_number %in% special_values)
```

Some ring numbers contain asterisks:

```{r show_asterisks}
birds_others %>% 
  filter(str_detect(bird_ring_number, "\\*")) %>%
  select(bird_ring_number)
```

We remove the asteriks:

```{r remove_*_in_ring_number}
birds_others <- 
  birds_others %>%
  mutate(bird_ring_number = gsub("\\*", "", bird_ring_number))
```

Add points `.` where needed:

```{r add_._in_ring_number}
birds_others <- 
  birds_others %>%
  mutate(reversed = stri_reverse(str = bird_ring_number))
idx <- as.data.frame(str_locate(birds_others$reversed, pattern = regex("\\d+")))$end
idx <- replace_na(idx, 0)
birds_others <- birds_others %>%
  mutate(bird_ring_number = stri_reverse(str_c(
    str_sub(reversed, 
          end = idx),
  map_chr(nchar(reversed), function(x) {
    ifelse(x < 10,
           str_c(rep(".", 10 - x), collapse = ""),
           "")
  }),
  str_sub(reversed, 
          start = idx + 1)))) %>%
  select(-reversed)
```

Merge the two data frames together:

```{r merge_back_together}
birds <- bind_rows(birds_others, birds_special_values)
```

Effects of mapping (part of it):

```{r}
birds %>% distinct(raw_MetaalringNummer, bird_ring_number)
### Euring

Present values:

```{r euring_in_db}
birds %>% distinct(raw_EuringCode)
```

We assign the euring codes by applying the following mapping:

```{r bird_euring}
crbirding_birds <-
  crbirding_birds %>%
  left_join(birds %>% 
              select(bird_reference, raw_EuringCode),
            by = "bird_reference") %>%
  mutate(bird_euring = recode(raw_EuringCode,
                              "5920" = "05920",
                              "5910" = "05910",
                              "5926" = "05926",
                              "5922" = "05922",
                              "zz" = NA_character_,
                              "zzz" = NA_character_)) %>%
  ungroup()
```

Effects of mapping:

```{r comparison_euring}
crbirding_birds %>% 
  distinct(raw_EuringCode, bird_euring)
```

### Scheme

Actual values:

```{r scheme}
birds %>% distinct(raw_MetaalringLandCode)
```

We apply the following mapping:

```{r scheme_mapping}
birds <- birds %>%
  mutate(bird_scheme = recode(raw_MetaalringLandCode,
                              "BE " = "BLB",
                              "FR" = "FRP",
                              "NL" = "NLA",
                              "PT" = "POL",
                              "UK" = "GBT"))
```

Effects of mapping:

```{r comparison_scheme}
birds %>% distinct(raw_MetaalringLandCode, bird_scheme)
```

### Bird sex

Bird sex is translated to English: `M` (mannetje) will not change so no need to convert it:

```{r sex}
birds <- birds %>%
  mutate(bird_sex = recode(raw_GeslachtCode,
    "V" = "F", # V(rouwtje) ->F(emale)
    "O" = "U" # O(nbekend) ->  U(nknown)
))
```

### Bird ringing date

The date of ringing (to be mapped as `bird_date_begin`) can be found in data frame `obs_and_acts` in the column `raw_Datum` relatively to code action `rngkl` (code action of applying colour ring).

```{r}
obs_and_acts %>% 
  filter(raw_AktieCode == "rngkl") %>%
  select(raw_KleurringNummer, raw_Datum) %>%
  head(n = 10)
```

### Bird age ringing

Map the age of the bird while ringing. This information can be found in column `raw_LeeftijdCode` of data frame `obs_and_acts` when related code action is equal to `rngkl` (code action of applying colour ring). Check for anomalies:

```{r retrieve_age_ringing}
birds <- left_join(obs_actions %>% 
                     select(raw_WaarnemingNummer, raw_AktieCode) %>%
                     filter(raw_AktieCode == "rngkl"), 
                   obs, 
                   by = c("raw_WaarnemingNummer" = "raw_Nummer")) %>%
  select(raw_WaarnemingNummer,
         raw_KleurringNummer,
         raw_LeeftijdCode) %>%
  right_join(birds, 
             by = c("raw_KleurringNummer" = "raw_Nummer"))
```

Mapping the age while applying color ring from INBO format to SOVON standard (Euring standard: see [online pdf document](https://euring.org/files/documents/E2000PLUSExchangeCodev1161.pdf) at page 14)

```{r}
birds <- birds %>%
  mutate(bird_age_ringing = recode(raw_LeeftijdCode,
    "PU" = "1",
    "AD" = "A",
    "J1" = "3",
    "I4" = "5",
    "I3" = "7",
    "I2" = "9",
    "I5" = "B",
    .missing = "O"))
```

### Bird shorthand

The INBO `tblKleurring` assumes the principle one row = one bird. Columns `rawNummer` and `rawNummerNieuw` refer to same bird: `rawNummer` is the first color ring the bird got, while `rawNummerNieuw` is the second one (in case it is different to `rawNummer`). `rawNummerDesc` is the dot version of `rawNummerNieuw` (dot has exclusively the function to improve readibility). SOVON table is organized differently: it assumes the principle one row = one color ring. We use information provided in `control_df` to map (most of) the rings.

### Bird ID

Bird identifiers will be provided by SOVON. `NA` is given:

```{r birdID}
birds <- birds %>%
  mutate(bird_id = NA)
```

### Bird BTO

Bird BTO will be provided by SOVON.  `NA` is given:

```{r bird_bto}
birds <- birds %>%
  mutate(bird_bto = NA)
```

### Bird name

Some birds, the ones with a GPS tracker, have a name saved in [this file](https://raw.githubusercontent.com/inbo/bird-tracking/master/data/interim/individuals.csv). The names are saved in column `individual_remarks`:

```{r read_names}
uvabits_file <- "https://raw.githubusercontent.com/inbo/bird-tracking/master/data/interim/individuals.csv"
uvabits_names <- 
  read_csv(uvabits_file) %>%
  select(individual_id, ring_number, individual_remarks, everything())
head(uvabits_names)
```

Assigning the name is given to the bird (based on `bird_reference`), by joining on `birdshorthand`:

```{r add_names}
bird_ref_uvabits <- 
  crbirding_birds %>%
  left_join(uvabits_names %>%
              select(colour_ring, individual_remarks), 
            by = c("bird_shorthand" = "colour_ring")) %>%
  rename("bird_name" = "individual_remarks") %>%
  filter(!is.na(bird_name)) %>%
  select(bird_reference, bird_name)
crbirding_birds <-
  crbirding_birds %>%
  left_join(bird_ref_uvabits, by = "bird_reference")
```

### Bird birth year

This field will be filled by SOVON. `NA` is given:

```{r bird_birth_year}
birds <- birds %>%
  mutate(bird_birth_year = NA)
```

### Bird date end

This field should be left to SOVON. `NA` is given:

```{r bird_date_end}
birds <- birds %>%
  mutate(bird_date_end = NA)
```

## Map observation data

### Observation reference

```{r obs_ref}
obs_and_acts <- obs_and_acts %>% mutate(observation_reference = raw_Nummer)
```

### Observation date

```{r obs_date}
obs_and_acts <- obs_and_acts %>% mutate(observation_date = raw_Datum)
```

### Observation time

No time is found for observations in `obs`. `NA` is given:

```{r obs_time}
obs_and_acts <- obs_and_acts %>% mutate(observation_time = NA)
```

### Observation latitude

Observation latitude should be converted to decimal degrees:

```{r obs_latitude}
obs_and_acts <- obs_and_acts %>% mutate(
  observation_lat = conv_unit(
    str_c(raw_PlaatsBreedtegraadGraden,
          raw_PlaatsBreedtegraadMinuten,
          raw_PlaatsBreedtegraadSeconden, 
          sep = " "), 
    from = 'deg_min_sec', to = 'dec_deg'
))
```

### Observation longitude

Observation longitude should be converted to decimal degrees:

```{r obs_longitude}
obs_and_acts <- obs_and_acts %>% mutate(
  observation_long = conv_unit(
    str_c(raw_PlaatsLengtegraadGraden,
          raw_PlaatsLengtegraadMinuten,
          raw_PlaatsLengtegraadSeconden, 
          sep = " "), 
    from = 'deg_min_sec', to = 'dec_deg'
))
```

### Observation location

Aggregate information about observation location. We follow the following structure: `raw_PlaatsGemeente` [+ `, ` + `raw_PlaatsToponym` [+ `: ` + `raw_PlaatsToponymDetail`]]:

```{r}
obs_and_acts <- obs_and_acts %>% mutate(
  observation_location = ifelse(!is.na(raw_PlaatsToponym),
                                str_c(raw_PlaatsGemeente,
                                      raw_PlaatsToponym, 
                                      sep = ", "),
                                paste(raw_PlaatsGemeente))) %>%
  mutate(observation_location = ifelse(!is.na(raw_PlaatsToponymDetail),
                                       str_c(observation_location,
                                             raw_PlaatsToponymDetail,
                                             sep = ": "),
                                       paste(observation_location)))
```

### Observation status

The need of adding the EURING status information arises by the need of mapping the observations with action code `br` and `vang`:

```{r breed_show}
actions_meaning %>%
  filter(Code %in% c("br", "vang"))
```

The actions `br` and `vang` refer to status `breeding` in EURING system. Based on the scheme at page 16 of [EURING Exchange Code 2000+](https://euring.org/files/documents/E2000PLUSExchangeCodev1161.pdf) document, we define the following mapping:

```{r}
obs_and_acts %>%
  mutate(status = case_when(
    raw_AktieCode %in% c("br", "vang") ~ "N",
    raw_LeeftijdCode == "PU" ~ "-",
    TRUE ~ "U"
  ))
```

### Observation reporter

The field `melder` is equal to `user_first_name` and `user_last_name` in `users`:

```{r obs_melder}
obs_and_acts <- obs_and_acts %>%
  left_join((users %>% select(raw_Nummer, user_first_name, user_last_name)),
            by = c("raw_WaarnemerNummer" = "raw_Nummer")) %>%
  mutate(melder = str_c(user_first_name, user_last_name, sep = " ")) %>%
  select(-c(user_first_name, user_last_name))
```

### Observation reporter reference number

The field `melder_ringersnummer` is equal to `user_reference` and should be left to SOVON. `NA` is given:

```{r melder_ringersnummer}
obs_and_acts <- obs_and_acts %>%
  mutate(melder_ringersnummer = NA)
```

### Observation notes

```{r obs_notes}
obs <- obs %>% mutate(observation_notes = raw_Opmerking)
```

### MRI: metal ring information

Metal ring information table can be found at page 8 of [this pdf document](https://euring.org/files/documents/E2000PLUSExchangeCodev1161.pdf)

A summary of the mapping follows:

1. observations with action code `meweg` should be mapped to 0 (metal ring is not present)

Further mapping steps need the knowledge of an expert.

```{r MRI}

```

# Post-processing

## User data 

Remove the original columns:

```{r user_remove_originals}
users <- users %>% select(-starts_with("raw_"))
```

Preview data:

```{r final_preview_users}
users %>% head()
```

Save to CSV:

```{r write_user_data_txt}
readr::write_csv(users, path = cr_users, na = "")
```

## Bird data

Remove the original columns:

```{r birds_remove_originals}
birds <- birds %>% select(-starts_with("raw_"))
```

Preview data:

```{r final_preview_birds}
birds %>% head()
```

Save to CSV:

```{r write_bird_data_txt}
readr::write_csv(birds, path = cr_birds, na = "")
```

## Observation data


Remove the original columns:

```{r obs_remove_originals}
obs <- obs %>% select(-starts_with("raw_"))
```

Preview data:

```{r final_preview_obs}
obs %>% head()
```

Save to CSV:

```{r write_obs_data_txt}
readr::write_csv(obs, path = cr_obs, na = "")
```
